/**
 * RefManager - Manages the mapping between refs and their selectors
 * 
 * This singleton class maintains a cache of refs generated by the snapshot command
 * and provides methods to resolve refs back to usable selectors for interaction commands.
 */

import { nodeToSelector } from './ref-utils'
import * as fs from 'fs'
import * as path from 'path'
import * as os from 'os'

interface RefEntry {
  ref: string
  selector: string
  role: string
  name: string
  tabId?: string
  timestamp: number
}

class RefManager {
  private static instance: RefManager
  private refMap: Map<string, RefEntry> = new Map()
  private tabRefMap: Map<string, Map<string, RefEntry>> = new Map()
  private persistFile: string
  
  private constructor() {
    // Store refs in temp directory
    this.persistFile = path.join(os.tmpdir(), 'playwright-cli-refs.json')
    this.loadFromDisk()
  }
  
  static getInstance(): RefManager {
    if (!RefManager.instance) {
      RefManager.instance = new RefManager()
    }
    return RefManager.instance
  }
  
  /**
   * Load refs from disk if file exists
   */
  private loadFromDisk(): void {
    try {
      if (fs.existsSync(this.persistFile)) {
        const data = fs.readFileSync(this.persistFile, 'utf-8')
        const parsed = JSON.parse(data)
        
        // Restore refMap
        this.refMap = new Map(Object.entries(parsed.refMap || {}))
        
        // Restore tabRefMap
        this.tabRefMap = new Map()
        for (const [tabId, entries] of Object.entries(parsed.tabRefMap || {})) {
          this.tabRefMap.set(tabId, new Map(Object.entries(entries as any)))
        }
      }
    } catch (error) {
      // Ignore errors, start with empty maps
    }
  }
  
  /**
   * Save refs to disk
   */
  private saveToDisk(): void {
    try {
      const data = {
        refMap: Object.fromEntries(this.refMap),
        tabRefMap: Object.fromEntries(
          Array.from(this.tabRefMap.entries()).map(([tabId, map]) => [
            tabId,
            Object.fromEntries(map)
          ])
        )
      }
      fs.writeFileSync(this.persistFile, JSON.stringify(data, null, 2))
    } catch (error) {
      // Ignore errors
    }
  }
  
  /**
   * Store a ref with its associated selector and metadata
   */
  storeRef(ref: string, node: any, tabId?: string): void {
    const selector = nodeToSelector(node)
    const entry: RefEntry = {
      ref,
      selector,
      role: node.role,
      name: node.name || node.value || '',
      tabId,
      timestamp: Date.now()
    }
    
    // Store in global map
    this.refMap.set(ref, entry)
    
    // Also store in per-tab map if tabId provided
    if (tabId) {
      if (!this.tabRefMap.has(tabId)) {
        this.tabRefMap.set(tabId, new Map())
      }
      this.tabRefMap.get(tabId)!.set(ref, entry)
    }
    
    // Persist to disk
    this.saveToDisk()
  }
  
  /**
   * Store multiple refs from a snapshot
   */
  storeSnapshot(elements: any[], tabId?: string): void {
    // Clear old refs for this tab to avoid stale references
    if (tabId && this.tabRefMap.has(tabId)) {
      this.tabRefMap.get(tabId)!.clear()
    }
    
    elements.forEach(element => {
      if (element.ref) {
        this.storeRef(element.ref, element, tabId)
      }
    })
    
    // Persist to disk after storing all
    this.saveToDisk()
  }
  
  /**
   * Get selector for a ref
   */
  getSelector(ref: string, tabId?: string): string | null {
    // Try tab-specific first
    if (tabId && this.tabRefMap.has(tabId)) {
      const tabEntry = this.tabRefMap.get(tabId)!.get(ref)
      if (tabEntry) {
        return tabEntry.selector
      }
    }
    
    // Fall back to global map
    const entry = this.refMap.get(ref)
    return entry ? entry.selector : null
  }
  
  /**
   * Get full entry for a ref
   */
  getEntry(ref: string, tabId?: string): RefEntry | null {
    // Try tab-specific first
    if (tabId && this.tabRefMap.has(tabId)) {
      const tabEntry = this.tabRefMap.get(tabId)!.get(ref)
      if (tabEntry) {
        return tabEntry
      }
    }
    
    // Fall back to global map
    return this.refMap.get(ref) || null
  }
  
  /**
   * Check if a ref exists
   */
  hasRef(ref: string, tabId?: string): boolean {
    if (tabId && this.tabRefMap.has(tabId)) {
      if (this.tabRefMap.get(tabId)!.has(ref)) {
        return true
      }
    }
    return this.refMap.has(ref)
  }
  
  /**
   * Clear all refs
   */
  clear(): void {
    this.refMap.clear()
    this.tabRefMap.clear()
    this.saveToDisk()
  }
  
  /**
   * Clear refs for a specific tab
   */
  clearTab(tabId: string): void {
    if (this.tabRefMap.has(tabId)) {
      this.tabRefMap.get(tabId)!.clear()
      this.tabRefMap.delete(tabId)
    }
    
    // Also remove from global map
    for (const [ref, entry] of this.refMap.entries()) {
      if (entry.tabId === tabId) {
        this.refMap.delete(ref)
      }
    }
    
    this.saveToDisk()
  }
  
  /**
   * Clean up old refs (older than 30 minutes by default)
   */
  cleanup(maxAge: number = 30 * 60 * 1000): void {
    const now = Date.now()
    
    // Clean global map
    for (const [ref, entry] of this.refMap.entries()) {
      if (now - entry.timestamp > maxAge) {
        this.refMap.delete(ref)
      }
    }
    
    // Clean tab maps
    for (const [tabId, tabMap] of this.tabRefMap.entries()) {
      for (const [ref, entry] of tabMap.entries()) {
        if (now - entry.timestamp > maxAge) {
          tabMap.delete(ref)
        }
      }
      
      // Remove empty tab maps
      if (tabMap.size === 0) {
        this.tabRefMap.delete(tabId)
      }
    }
    
    this.saveToDisk()
  }
  
  /**
   * Get all refs for a tab
   */
  getTabRefs(tabId: string): RefEntry[] {
    if (!this.tabRefMap.has(tabId)) {
      return []
    }
    
    return Array.from(this.tabRefMap.get(tabId)!.values())
  }
  
  /**
   * Get statistics about stored refs
   */
  getStats(): { totalRefs: number; tabs: number; oldestRef: number | null } {
    let oldestTimestamp: number | null = null
    
    for (const entry of this.refMap.values()) {
      if (!oldestTimestamp || entry.timestamp < oldestTimestamp) {
        oldestTimestamp = entry.timestamp
      }
    }
    
    return {
      totalRefs: this.refMap.size,
      tabs: this.tabRefMap.size,
      oldestRef: oldestTimestamp
    }
  }
}

// Export singleton instance
export const refManager = RefManager.getInstance()

// Export the class for testing
export { RefManager, RefEntry }